# templ_heroicons_generator/core/templ_builder.py

import os
# import sys # No longer needed if sys.exit is removed
from jinja2 import Environment
from typing import List, Optional

from .icons import Icon
from .utils import is_valid_go_package_name
from . import config


def generate_heroicons_package(
    output_dir: str,
    icons: List[Icon],
    force: bool,
    verbose: bool,
    dry_run: bool,
    default_class: str,
) -> Optional[str]:
    """
    Generates the heroicons.templ Go package file content.

    This function takes a list of processed Icon objects and renders them into
    a Go Templ file using a Jinja2 template. It handles Go package naming by
    deriving it from the output directory name, ensures the output directory
    exists, and avoids rewriting the file if its content hasn't changed (unless
    `force` is True). Constants like the output filename, Heroicons source URLs,
    and fallback package name are read from `core.config`.

    Args:
        output_dir: The directory where the .templ file will be written.
        icons: A list of `Icon` objects to include in the generated package.
        force: If True, overwrite the output file even if content is identical.
        verbose: If True, prints detailed logs during generation.
        dry_run: If True, does not write to a file but returns the content.
                 The caller (cli.py) is responsible for printing it.
        default_class: The default CSS class to apply to the SVG elements.
                       This value is typically supplied via CLI arguments.

    Returns:
        The rendered content as a string. If `dry_run` is False, this content
        is also written to the output file (if changes are detected or `force` is True).
        Returns the content string regardless of whether it was written to a file or not
        (unless a critical error occurs causing an exception).

    Raises:
        RuntimeError: If template rendering fails or an unexpected error occurs during file writing.
        OSError: If the output directory cannot be created.
        IOError: If writing to the output file fails.
    """
    normalized_output_dir = os.path.normpath(output_dir)
    derived_package_name = os.path.basename(normalized_output_dir)
    if not derived_package_name or derived_package_name in ('.', '..'):
        derived_package_name = os.path.basename(os.path.abspath(output_dir))

    package_name: str
    if is_valid_go_package_name(derived_package_name):
        package_name = derived_package_name
        if verbose:
            print(f"  Using Go package name: '{package_name}'")
    else:
        package_name = config.DEFAULT_FALLBACK_PACKAGE_NAME
        # This warning is important and should be shown if fallback is used.
        # cli.py will print it if this function raises an error, or we can print here if verbose.
        # For now, let's keep it simple; cli.py can catch a specific exception if needed for this.
        # Or, this function could return a status/message tuple.
        # A simple print if verbose is fine for now.
        if verbose:
            print(f"  Warning: Derived package name '{derived_package_name}' from '{output_dir}' is invalid. "
                  f"Using fallback '{package_name}'.")


    output_path = os.path.join(output_dir, config.OUTPUT_FILENAME)
    abs_output_path = os.path.abspath(output_path)
    output_dirname = os.path.dirname(abs_output_path)
    try:
        relative_output_path = os.path.relpath(abs_output_path)
    except ValueError: # Handles cases like different drives on Windows
        relative_output_path = abs_output_path


    if verbose:
        print(f"  Generating content for {relative_output_path} with {len(icons)} icon(s) for package '{package_name}'...")

    env = Environment(
        trim_blocks=True,
        lstrip_blocks=True,
        keep_trailing_newline=True,
        autoescape=True
    )

    template_str = """\
// Code generated by templ-heroicons-generator. DO NOT EDIT.
// Source: {{ heroicons_base_url }}
// Version: {{ heroicons_version }}
package {{ package_name }}

// Requires: templ v0.2.513 or later (Refer to https://templ.guide/project-setup/installation)
// Heroicons: https://heroicons.com/
{% if not icons_list %}
// No icons were found or processed by the generation script.
// This file may be empty or contain only comments.
{% endif %}
{% for icon_obj in icons_list %}
// {{ icon_obj.component_name }} renders the '{{ icon_obj.file_name }}' icon ({{ icon_obj.style }} style).
// Source: {{ heroicons_base_url }}/{{ icon_obj.style }}/{{ icon_obj.file_name }}.svg
templ {{ icon_obj.component_name }}(attrs templ.Attributes) {
	<svg
		xmlns="http://www.w3.org/2000/svg"
		{% if icon_obj.style == 'outline' %}
		fill="none"
		viewBox="0 0 24 24"
		stroke-width="1.5"
		stroke="currentColor"
		{% else %}
		fill="currentColor"
		viewBox="0 0 24 24"
		{% endif %}
        {% raw %}{ attrs... }{% endraw %}
		class="{{ default_svg_class }}"
	>
		{% for element in icon_obj.elements %}
		<{{ element.tag }}
			{% for key, value in element.attrs.items() %}
			{{ key }}="{{ value }}"
			{% endfor %}
		/>
		{% endfor %}
	</svg>
}
{% endfor %}
"""
    try:
        template = env.from_string(template_str)
        rendered_content = template.render(
            icons_list=icons,
            heroicons_base_url=config.HEROICONS_BASE_URL,
            heroicons_version=config.HEROICONS_VERSION,
            package_name=package_name,
            default_svg_class=default_class
        ).strip() + "\n"
    except Exception as e:
        raise RuntimeError(f"Failed to render template: {e}")

    if dry_run:
        return rendered_content

    try:
        os.makedirs(output_dirname, exist_ok=True)
    except OSError as e:
        raise OSError(f"Could not create output directory '{output_dirname}': {e}")

    file_exists = os.path.exists(abs_output_path)
    should_write = True

    if file_exists and not force:
        try:
            with open(abs_output_path, "r", encoding="utf-8") as f:
                existing_content = f.read()

            normalized_existing = existing_content.replace('\r\n', '\n').strip()
            normalized_rendered = rendered_content.replace('\r\n', '\n').strip()

            if normalized_existing == normalized_rendered:
                if verbose:
                    print(f"  Content of '{relative_output_path}' is up-to-date. No changes needed.")
                should_write = False
            elif verbose:
                print(f"  Content of '{relative_output_path}' differs. Will overwrite.")
        except Exception as e:
            if verbose:
                print(f"  Warning: Could not read existing file '{relative_output_path}' for comparison: {e}. Proceeding to overwrite.")

    if should_write:
        try:
            with open(abs_output_path, "w", encoding="utf-8", newline='\n') as f:
                f.write(rendered_content)
            action_word = "Created" if not file_exists or (file_exists and force) else "Updated"
            if verbose:
                 print(f"  Successfully {action_word.lower()} {relative_output_path}")
        except IOError as e:
            raise IOError(f"Failed writing to '{abs_output_path}': {e}")
        except Exception as e:
             raise RuntimeError(f"An unexpected error occurred while writing '{abs_output_path}': {e}")

    return rendered_content
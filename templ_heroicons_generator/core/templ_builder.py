# templ_heroicons_generator/core/templ_builder.py

import os
from jinja2 import Environment, select_autoescape
from typing import List, Optional

from .icons import Icon
from .utils import is_valid_go_package_name
from . import config


def generate_heroicons_package(
    output_dir: str,
    icons: List[Icon],
    force: bool,
    verbose: bool,
    dry_run: bool,
    default_class: str,
) -> Optional[str]:
    """
    Generates the heroicons.templ Go package file content.

    This function takes a list of processed Icon objects and renders them into
    a Go Templ file using a Jinja2 template. It handles Go package naming by
    deriving it from the output directory name, ensures the output directory
    exists, and avoids rewriting the file if its content hasn't changed (unless
    `force` is True). Constants like the output filename, Heroicons source URLs,
    and fallback package name are read from `core.config`.

    Args:
        output_dir: The directory where the .templ file will be written.
        icons: A list of `Icon` objects to include in the generated package.
        force: If True, overwrite the output file even if content is identical.
        verbose: If True, prints detailed logs during generation.
        dry_run: If True, does not write to a file but returns the content.
        default_class: The default CSS class to apply to the SVG elements.

    Returns:
        The rendered content as a string. If `dry_run` is False, this content
        is also written to the output file (if changes are detected or `force` is True).
        Returns the content string regardless of whether it was written to a file or not
        (unless a critical error occurs causing an exception).

    Raises:
        RuntimeError: If template rendering fails or an unexpected error occurs during file writing.
        OSError: If the output directory cannot be created.
        IOError: If writing to the output file fails.
    """
    normalized_output_dir = os.path.normpath(output_dir)
    derived_package_name = os.path.basename(normalized_output_dir)
    if not derived_package_name or derived_package_name in ('.', '..'):
        # Fallback if basename is empty (e.g. output_dir is '/') or relative dot
        derived_package_name = os.path.basename(os.path.abspath(output_dir))

    package_name: str
    if is_valid_go_package_name(derived_package_name):
        package_name = derived_package_name
        if verbose:
            print(f"  Using Go package name: '{package_name}' derived from output directory.")
    else:
        package_name = config.DEFAULT_FALLBACK_PACKAGE_NAME
        if verbose: # This warning is important
            print(f"  Warning: Derived package name '{derived_package_name}' from '{output_dir}' is invalid. "
                  f"Using fallback Go package name '{package_name}'.")

    output_path = os.path.join(output_dir, config.OUTPUT_FILENAME)
    abs_output_path = os.path.abspath(output_path)
    output_dirname = os.path.dirname(abs_output_path)

    try:
        # For display purposes, use relative path if possible
        relative_output_path = os.path.relpath(abs_output_path)
    except ValueError: # Handles cases like different drives on Windows
        relative_output_path = abs_output_path

    if verbose:
        msg_verb = "Previewing content for" if dry_run else "Generating content for"
        print(f"  {msg_verb} {relative_output_path} with {len(icons)} icon(s) for package '{package_name}'...")

    # Note: `autoescape=True` is generally good practice but for this specific template
    # generating Go/SVG code, explicit escaping is less critical than for HTML generation.
    # However, it's safe to keep. `select_autoescape()` provides more control if needed.
    env = Environment(
        loader=None, # We are using from_string
        autoescape=select_autoescape(['html', 'xml']), # Standard practice
        trim_blocks=True,
        lstrip_blocks=True,
        keep_trailing_newline=True # Ensures template's own trailing newline is respected before strip()
    )

    # Jinja2 template string
    # Ensure { attrs... } is handled correctly by Jinja using {% raw %}
    template_str = """\
// Code generated by generate_heroicons.py. DO NOT EDIT.
// Source: {{ HEROICONS_BASE_URL }}
// Version: {{ HEROICONS_VERSION }}
package {{ package_name }}

// Requires: templ v0.2.513 or later
// Web: https://heroicons.com/
{% if not icons %}
// No icons found or processed by the generation script.
{% endif %}
{% for icon in icons %}
// {{ icon.component_name }} renders the '{{ icon.file_name }}' icon ({{ icon.style }} style).
// Source: {{ HEROICONS_BASE_URL }}/{{ icon.style }}/{{ icon.file_name }}.svg
templ {{ icon.component_name }}(attrs templ.Attributes) {
	<svg
		xmlns="http://www.w3.org/2000/svg"
		{# Add newlines and indentation for SVG attributes #}
		{% if icon.style == 'outline' %}
		fill="none"
		viewBox="0 0 24 24"
		stroke-width="1.5"
		stroke="currentColor"
		{% else %}
		fill="currentColor"
		viewBox="0 0 24 24"
		{% endif %}
        { attrs... }
		class="{{ default_class }}"
	>
		{# Ensure newline/indentation before inner elements #}
		{% for element in icon.elements %}
		<{{ element.tag }}
			{# Loop through element attributes, adding newline/indent for each #}
			{% for key, value in element.attrs.items() %}
			{{ key }}="{{ value }}"
			{% endfor %}
		/>
		{% endfor %}
	</svg>
}
{% endfor %}
"""
    try:
        template = env.from_string(template_str)
        rendered_content = template.render(
            icons_list=icons,
            heroicons_base_url=config.HEROICONS_BASE_URL,
            heroicons_version=config.HEROICONS_VERSION,
            package_name=package_name,
            default_svg_class=default_class
        )
        # Ensure a single newline at the very end of the file content.
        # Jinja's keep_trailing_newline and the template's final newline might interact.
        # Stripping all whitespace and adding one newline is a robust way.
        rendered_content = rendered_content.strip() + "\n"

    except Exception as e:
        # This makes the error message more specific if rendering fails.
        raise RuntimeError(f"Failed to render Jinja2 template for Heroicons: {e}")

    if dry_run:
        # The caller (cli.py) is responsible for printing this content.
        return rendered_content

    # Create output directory if it doesn't exist
    try:
        os.makedirs(output_dirname, exist_ok=True)
    except OSError as e:
        # More specific error if directory creation fails
        raise OSError(f"Could not create output directory '{output_dirname}': {e}")

    file_exists = os.path.exists(abs_output_path)
    should_write = True

    if file_exists and not force:
        try:
            with open(abs_output_path, "r", encoding="utf-8") as f:
                existing_content = f.read()

            # Normalize newlines for comparison to avoid false positives on different OS
            # Also strip trailing whitespace from both for a more robust comparison
            normalized_existing = existing_content.replace('\r\n', '\n').strip()
            normalized_rendered = rendered_content.replace('\r\n', '\n').strip()

            if normalized_existing == normalized_rendered:
                if verbose:
                    print(f"  Content of '{relative_output_path}' is up-to-date. No changes needed.")
                should_write = False
            elif verbose:
                print(f"  Content of '{relative_output_path}' differs. Will overwrite.")
        except Exception as e:
            # If comparison fails, it's safer to assume we need to write,
            # especially if the file is unreadable for some reason.
            if verbose:
                print(f"  Warning: Could not read existing file '{relative_output_path}' for comparison: {e}. "
                      "Proceeding to overwrite.")

    if should_write:
        try:
            # Explicitly use newline='\n' to ensure consistent LF line endings
            with open(abs_output_path, "w", encoding="utf-8", newline='\n') as f:
                f.write(rendered_content)
            action_word = "Created"
            if file_exists:
                action_word = "Overwritten" if force else "Updated"

            if verbose:
                 print(f"  Successfully {action_word.lower()} '{relative_output_path}'.")
        except IOError as e:
            raise IOError(f"Failed writing to '{abs_output_path}': {e}")
        except Exception as e: # Catch-all for other unexpected write errors
             raise RuntimeError(f"An unexpected error occurred while writing '{abs_output_path}': {e}")

    return rendered_content
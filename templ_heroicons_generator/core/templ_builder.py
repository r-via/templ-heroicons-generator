# templ_heroicons_generator/core/templ_builder.py

import os
from jinja2 import Environment, select_autoescape
from typing import List, Optional

from .icons import Icon
from .utils import is_valid_go_package_name
from . import config


def generate_heroicons_package(
    output_dir: str,
    icons: List[Icon],
    force: bool,
    verbose: bool,
    silent: bool,
    dry_run: bool,
    default_class: str,
) -> Optional[str]:
    """
    Generates the heroicons.templ Go package file content.

    It determines the Go package name from the output directory, renders
    the Templ components using a Jinja2 template, and then writes the content
    to the specified output file. Handles existing file comparison to avoid
    unnecessary writes unless `force` is True.

    Args:
        output_dir: The directory where the 'heroicons.templ' file will be written.
        icons: A list of `Icon` objects to generate components for.
        force: If True, overwrite the output file even if content hasn't changed.
        verbose: If True (and silent is False), prints detailed logs.
        silent: If True, suppresses all informational output except critical errors.
        dry_run: If True, returns the generated content instead of writing to a file.
        default_class: The default CSS class to apply to SVG elements.

    Returns:
        The generated content as a string if `dry_run` is True.
        None otherwise, or if an error occurs preventing file writing (though errors
        will typically raise exceptions).

    Raises:
        RuntimeError: If Jinja2 template rendering fails.
        OSError: If creating the output directory fails.
        IOError: If writing the output file fails.
    """
    normalized_output_dir = os.path.normpath(output_dir)
    derived_package_name = os.path.basename(normalized_output_dir)
    if not derived_package_name or derived_package_name in (".", ".."):
        derived_package_name = os.path.basename(os.path.abspath(output_dir))

    package_name: str
    if is_valid_go_package_name(derived_package_name):
        package_name = derived_package_name
        if verbose:  # Implies not silent
            print(
                f"  Using Go package name: '{package_name}' derived from output directory."
            )
    else:
        package_name = config.DEFAULT_FALLBACK_PACKAGE_NAME
        if verbose:  # Implies not silent
            print(
                f"  Warning: Derived package name '{derived_package_name}' from '{output_dir}' is invalid. "
                f"Using fallback Go package name '{package_name}'."
            )
        elif not silent:  # A warning, but not verbose
            print(
                f"Warning: Derived package name '{derived_package_name}' is invalid, using '{package_name}'.",
                file=sys.stderr,
            )

    output_path = os.path.join(output_dir, config.OUTPUT_FILENAME)
    abs_output_path = os.path.abspath(output_path)
    output_dirname = os.path.dirname(abs_output_path)

    try:
        relative_output_path = os.path.relpath(abs_output_path)
    except ValueError:
        relative_output_path = abs_output_path

    if verbose:  # Implies not silent
        msg_verb = "Previewing content for" if dry_run else "Generating content for"
        print(
            f"  {msg_verb} {relative_output_path} with {len(icons)} icon(s) for package '{package_name}'..."
        )
    elif not silent and not dry_run:  # Not verbose, not silent, and not a dry run
        print(f"Generating {relative_output_path} for package '{package_name}'...")

    env = Environment(
        loader=None,  # Template is a string
        autoescape=select_autoescape(["html", "xml"]),  # Autoescape HTML/XML
        trim_blocks=True,  # Remove first newline after a block
        lstrip_blocks=True,  # Strip leading whitespace from line before block
        keep_trailing_newline=True,  # Preserve single trailing newline if present in template
    )

    template_str = """\
// Code generated by templ-heroicons-generator. DO NOT EDIT.
// Source: {{ heroicons_base_url }}
// Version: {{ heroicons_version }}
package {{ package_name }}

// Requires: templ v0.2.513 or later
// Web: https://heroicons.com/
{% if not icons_list %}
// No icons were found or processed by the generation script.
{% endif %}
{% for icon_obj in icons_list %}
// {{ icon_obj.component_name }} renders the '{{ icon_obj.file_name }}' icon ({{ icon_obj.style }} style).
// Source: {{ heroicons_base_url }}/{{ icon_obj.style }}/{{ icon_obj.file_name }}.svg
templ {{ icon_obj.component_name }}(attrs templ.Attributes) {
	<svg
		xmlns="http://www.w3.org/2000/svg"
		{% if icon_obj.style == 'outline' %}
		fill="none"
		viewBox="0 0 24 24"
		stroke-width="1.5"
		stroke="currentColor"
		{% else %}
		fill="currentColor"
		viewBox="0 0 24 24"
		{% endif %}
        { attrs... }
		class="{{ default_svg_class }}"
	>
		{% for element in icon_obj.elements %}
		<{{ element.tag }}
			{% for key, value in element.attrs.items() %}
			{{ key }}="{{ value }}"
			{% endfor %}
		/>
		{% endfor %}
	</svg>
}
{% endfor %}
"""
    try:
        template = env.from_string(template_str)
        rendered_content = (
            template.render(
                icons_list=icons,
                heroicons_base_url=config.HEROICONS_BASE_URL,
                heroicons_version=config.HEROICONS_VERSION,
                package_name=package_name,
                default_svg_class=default_class,
            ).strip()
            + "\n"
        )  # Ensure a single trailing newline
    except Exception as e:
        # This is a critical error, raise it so it's caught by top-level handler
        raise RuntimeError(f"Failed to render Jinja2 template for Heroicons: {e}")

    if dry_run:
        # For dry_run, content is returned to be printed by cli.py
        return rendered_content

    # --- File Writing Logic (Not dry_run) ---
    try:
        os.makedirs(output_dirname, exist_ok=True)
    except OSError as e:
        # Critical error, should be caught by top-level handler
        raise OSError(f"Could not create output directory '{output_dirname}': {e}")

    file_exists = os.path.exists(abs_output_path)
    should_write = True

    if file_exists and not force:
        try:
            with open(abs_output_path, "r", encoding="utf-8") as f:
                existing_content = f.read()
            # Normalize newlines and strip for comparison
            normalized_existing = existing_content.replace("\r\n", "\n").strip()
            normalized_rendered = rendered_content.replace("\r\n", "\n").strip()

            if normalized_existing == normalized_rendered:
                if verbose:  # Implies not silent
                    print(
                        f"  Content of '{relative_output_path}' is up-to-date. No changes needed."
                    )
                elif not silent:  # Not verbose, not silent, but up-to-date
                    print(f"'{relative_output_path}' is up-to-date.")
                should_write = False
            elif verbose:  # Implies not silent, content differs
                print(f"  Content of '{relative_output_path}' differs. Will overwrite.")
        except Exception as e:
            # If comparison fails, assume we should write, with a warning if verbose
            if verbose:  # Implies not silent
                print(
                    f"  Warning: Could not read existing file '{relative_output_path}' for comparison: {e}. "
                    "Proceeding to overwrite.",
                    file=sys.stderr,
                )
            # No message if not verbose and not silent for this minor warning

    if should_write:
        try:
            with open(
                abs_output_path, "w", encoding="utf-8", newline="\n"
            ) as f:  # Use newline='\n' for consistent LF
                f.write(rendered_content)

            action_word = "Created"
            if file_exists:
                action_word = "Overwritten" if force else "Updated"

            if verbose:  # Implies not silent
                print(f"  Successfully {action_word.lower()} '{relative_output_path}'.")
            elif not silent:  # Not verbose, not silent
                print(f"{action_word} '{relative_output_path}'.")
        except IOError as e:
            # Critical error
            raise IOError(f"Failed writing to '{abs_output_path}': {e}")
        except Exception as e:
            # Other unexpected critical errors
            raise RuntimeError(
                f"An unexpected error occurred while writing '{abs_output_path}': {e}"
            )

    return (
        rendered_content if dry_run else None
    )  # Should be None if not dry_run and written

# templ_heroicons_generator/core/templ_builder.py

import os
from jinja2 import Environment, select_autoescape
from typing import List, Optional

from .icons import Icon
from .utils import is_valid_go_package_name
from . import config


def generate_heroicons_package(
    output_dir: str,
    icons: List[Icon], # Le nom du paramètre est 'icons'
    force: bool,
    verbose: bool,
    dry_run: bool,
    default_class: str, # Le nom du paramètre est 'default_class'
) -> Optional[str]:
    """
    Generates the heroicons.templ Go package file content.
    (Description complète comme dans les versions précédentes)
    """
    normalized_output_dir = os.path.normpath(output_dir)
    derived_package_name = os.path.basename(normalized_output_dir)
    if not derived_package_name or derived_package_name in ('.', '..'):
        derived_package_name = os.path.basename(os.path.abspath(output_dir))

    package_name: str
    if is_valid_go_package_name(derived_package_name):
        package_name = derived_package_name
        if verbose:
            print(f"  Using Go package name: '{package_name}' derived from output directory.")
    else:
        package_name = config.DEFAULT_FALLBACK_PACKAGE_NAME
        if verbose:
            print(f"  Warning: Derived package name '{derived_package_name}' from '{output_dir}' is invalid. "
                  f"Using fallback Go package name '{package_name}'.")

    output_path = os.path.join(output_dir, config.OUTPUT_FILENAME)
    abs_output_path = os.path.abspath(output_path)
    output_dirname = os.path.dirname(abs_output_path)

    try:
        relative_output_path = os.path.relpath(abs_output_path)
    except ValueError:
        relative_output_path = abs_output_path

    if verbose:
        msg_verb = "Previewing content for" if dry_run else "Generating content for"
        print(f"  {msg_verb} {relative_output_path} with {len(icons)} icon(s) for package '{package_name}'...")

    env = Environment(
        loader=None,
        autoescape=select_autoescape(['html', 'xml']),
        trim_blocks=True,
        lstrip_blocks=True,
        keep_trailing_newline=True
    )

    # Utilisation du template qui fonctionnait bien pour le formatage de { attrs... }
    # Les noms de variables Jinja dans le template doivent correspondre aux clés passées à `template.render()`
    template_str = """\
// Code generated by templ-heroicons-generator. DO NOT EDIT.
// Source: {{ heroicons_base_url }}
// Version: {{ heroicons_version }}
package {{ package_name }}

// Requires: templ v0.2.513 or later
// Web: https://heroicons.com/
{% if not icons_list %}
// No icons were found or processed by the generation script.
{% endif %}
{% for icon_obj in icons_list %}
// {{ icon_obj.component_name }} renders the '{{ icon_obj.file_name }}' icon ({{ icon_obj.style }} style).
// Source: {{ heroicons_base_url }}/{{ icon_obj.style }}/{{ icon_obj.file_name }}.svg
templ {{ icon_obj.component_name }}(attrs templ.Attributes) {
	<svg
		xmlns="http://www.w3.org/2000/svg"
		{# Add newlines and indentation for SVG attributes #}
		{% if icon_obj.style == 'outline' %}
		fill="none"
		viewBox="0 0 24 24"
		stroke-width="1.5"
		stroke="currentColor"
		{% else %}
		fill="currentColor"
		viewBox="0 0 24 24"
		{% endif %}
        { attrs... }
		class="{{ default_svg_class }}"
	>
		{# Ensure newline/indentation before inner elements #}
		{% for element in icon_obj.elements %}
		<{{ element.tag }}
			{# Loop through element attributes, adding newline/indent for each #}
			{% for key, value in element.attrs.items() %}
			{{ key }}="{{ value }}"
			{% endfor %}
		/>
		{% endfor %}
	</svg}
}
{% endfor %}
"""
    try:
        template = env.from_string(template_str)
        # Les clés ici (ex: 'icons_list') doivent correspondre aux variables utilisées dans le template_str
        rendered_content = template.render(
            icons_list=icons,                   # Correspond à {% for icon_obj in icons_list %}
            heroicons_base_url=config.HEROICONS_BASE_URL,
            heroicons_version=config.HEROICONS_VERSION,
            package_name=package_name,
            default_svg_class=default_class     # Correspond à class="{{ default_svg_class }}"
        ).strip() + "\n"
    except Exception as e:
        raise RuntimeError(f"Failed to render Jinja2 template for Heroicons: {e}")

    if dry_run:
        return rendered_content

    try:
        os.makedirs(output_dirname, exist_ok=True)
    except OSError as e:
        raise OSError(f"Could not create output directory '{output_dirname}': {e}")

    file_exists = os.path.exists(abs_output_path)
    should_write = True

    if file_exists and not force:
        try:
            with open(abs_output_path, "r", encoding="utf-8") as f:
                existing_content = f.read()
            normalized_existing = existing_content.replace('\r\n', '\n').strip()
            normalized_rendered = rendered_content.replace('\r\n', '\n').strip()
            if normalized_existing == normalized_rendered:
                if verbose:
                    print(f"  Content of '{relative_output_path}' is up-to-date. No changes needed.")
                should_write = False
            elif verbose:
                print(f"  Content of '{relative_output_path}' differs. Will overwrite.")
        except Exception as e:
            if verbose:
                print(f"  Warning: Could not read existing file '{relative_output_path}' for comparison: {e}. "
                      "Proceeding to overwrite.")

    if should_write:
        try:
            with open(abs_output_path, "w", encoding="utf-8", newline='\n') as f:
                f.write(rendered_content)
            action_word = "Created"
            if file_exists:
                action_word = "Overwritten" if force else "Updated"
            if verbose:
                 print(f"  Successfully {action_word.lower()} '{relative_output_path}'.")
        except IOError as e:
            raise IOError(f"Failed writing to '{abs_output_path}': {e}")
        except Exception as e:
             raise RuntimeError(f"An unexpected error occurred while writing '{abs_output_path}': {e}")

    return rendered_content